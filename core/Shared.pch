// @v 1.1.0
// @n Motus_Lib
// @a Armin Hamar
// @l https://www.binpress.com/license/view/l/dc100faf74fa8ba3d613f8255ae1ef73
#pragma once
#include <cstdlib>
#include <initializer_list>

// Header
#define MT_VERSION_1_1_0
// Header

using i64 = long long;

template<typename T>
class Shared
{
private:
    T* ptr;
    
    template<typename TX>
    struct Shared_Info
    {
        TX* origin;
        i64 refs;
    };
    Shared_Info<T>* type_info;
public:
    T* ref() const
    {
        return ptr;
    }
    
    i64 getRefCount() const
    {
        return type_info->refs;
    }
    
    i64& getRefCounter()
    {
        return type_info->refs;
    }
    
    Shared(T* raw_memory)
    {
        type_info = (Shared_Info<T>*)calloc(1,sizeof(type_info));
        type_info->origin = raw_memory;
        ptr = type_info->origin;
    }
    
    
    Shared(Shared<T>& shr)
    {
        this->type_info->origin = shr.ref();
        this->type_info->refs   = shr.getRefCounter();
        this->type_info->refs   += 1;
    }
    
    Shared(Shared<T>&& shr)
    {
        this->type_info->origin = shr.ref();
        this->type_info->refs   = shr.getRefCounter();
        this->type_info->refs   += 1;
    }
    
    ~Shared()
    {
        if(type_info->refs <= 0)
        {
            free(ptr);
        }
        else
        {
            type_info->refs -= 1;
        }
    }
};

template<typename T>
Shared<T> make_shared(i64 count)
{
    return Shared<T>( (T*)calloc(count,sizeof(T)) );
}

template<typename T>
Shared<T> make_shared(std::initializer_list<T> init_list)
{
    T* begin = (T*)calloc(init_list.size(),*init_list.begin());
    for(const T& e : init_list)
    {
        *begin++ = e;
    }
    begin = begin - init_list.size();
    return Shared<T>(begin);
};
